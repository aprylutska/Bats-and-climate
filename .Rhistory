mod <- lm(log(W) ~ log(day), data = df)
# Get residuals
df$BMI <- residuals(mod)
# Drop unused variables
rm(mod)
check_my_var(df, "BMI", "day")
ggplot(data = df, aes(Year, BMI)) +
geom_violin() +
labs(y = "Body Mass Index")
ggplot(data = df, aes(day, BMI, colour = Year)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", aes(fill = Year)) +
labs(x = "Day of the year",
y = "Body Mass Index")
# facet_wrap(vars(sex))
# Take a look at the timespan
summary(df$date)
# Create data frame with point coordinates
coords <- read.csv("./data/coords.csv") %>%
# Make a new variable with places' unique identifiers
unite("place_id", Territory:place, remove = FALSE) %>%
select(-c(Territory, place))
#
#
# # coords <- data.frame(
# #   place = c("R1", "R2", "Fed1", "Fed2", "Fed3", "F1", "F2", "F3", "F4"),
# #   lon = c(36.33329, 36.32946, 36.32732, 36.32863, 36.33436, 36.32396, 36.32319, 36.31990, 36.31909),
# #   lat = c(49.62554, 49.62092, 49.62298, 49.61411, 49.60477, 49.61782, 49.61169, 49.60948, 49.60782)
# # )
# #
# # coords %>%
# #   mutate(Territory = "Homilsha") %>%
# #   relocate(Territory) %>%
# #   write.csv("coords.csv", row.names = FALSE)
#
#
#
#
# # Retrieve daily weather values using {easyclimate} package
# # Prcp - Total precipitation in mm
# # Tmin - minimal temperature, Celsius degrees
# # Tmax - maximal temperature, Celsius degrees
#
daily <- get_daily_climate(
coords = coords,
period = 2008:2019,
climatic_var = c("Prcp","Tmin","Tmax"),
output = "df") %>%
mutate(Tmean = (Tmax + Tmin) / 2) %>%
select(-Tmin, -Tmax)
#
# save(daily, file = "./data/daily_weather_2008-2019.Rdata") # save weather data
View(daily)
#
save(daily, file = "./data/daily_weather_2008-2019.Rdata") # save weather data
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls()) # reset R's brain
library(tidyverse) # for data manipulations
library(lubridate) # for transforming date variables
library(easyclimate) # for daily climate data extraction
library(sf) # for spatial operations
library(gridExtra) # for ggplot plates
# library(jtools)
# Set custom theme for ggplot2 plots
mytheme <- theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
# Set custom theme as a default for all ggplot below
theme_set(mytheme)
# if LC_TIME=uk_UA.UTF-8, your months will be in Ukrainian.
# To fix that, you need to re-map locate into US (will be back after restart R session)
# Set locale to get English months names
# Sys.setlocale("LC_TIME", "en_US.UTF-8") # for Linux
# Sys.setlocale("LC_TIME", "English") # for Windows
# Custom function to check dependency of selected growth metric on day across years
source("./functions/check_my_var.R")
# Read data and prepare it for further analyses
df <- read.csv("./data/Inventory_all_years_2024-04-04_OP.csv") %>%
mutate(date = dmy(Data)) %>%
mutate(Year = year(date)) %>%
# day of the year (start from the 1st Jan of each year)
mutate(day = yday(date)) %>%
select(-Data) %>%
select(-ring) %>%
# Drop rows with NAs in W and Ra
filter(complete.cases(.)) %>%
# Drop empty strings (which are not NAs)
filter(Place != "") %>%
filter(Species == "Nyctalus noctula" &
age == "sad") %>%
select(-Species, -age) %>%
# Make a new variable with places' unique identifiers
unite("place_id", Territory:Place, remove = FALSE) %>%
mutate(across(c(place_id, Territory, Place, sex, Year),
as.factor))
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls()) # reset R's brain
library(tidyverse) # for data manipulations
library(lubridate) # for transforming date variables
library(easyclimate) # for daily climate data extraction
library(sf) # for spatial operations
library(gridExtra) # for ggplot plates
# library(jtools)
# Set custom theme for ggplot2 plots
mytheme <- theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
# Set custom theme as a default for all ggplot below
theme_set(mytheme)
# if LC_TIME=uk_UA.UTF-8, your months will be in Ukrainian.
# To fix that, you need to re-map locate into US (will be back after restart R session)
# Set locale to get English months names
# Sys.setlocale("LC_TIME", "en_US.UTF-8") # for Linux
# Sys.setlocale("LC_TIME", "English") # for Windows
# Custom function to check dependency of selected growth metric on day across years
source("./functions/check_my_var.R")
# Read data and prepare it for further analyses
df <- read.csv("./data/Inventory_all_years_2024-04-04_OP.csv") %>%
mutate(date = dmy(Data)) %>%
mutate(Year = year(date)) %>%
# day of the year (start from the 1st Jan of each year)
mutate(day = yday(date)) %>%
select(-Data) %>%
select(-ring) %>%
# Drop rows with NAs in W and Ra
filter(complete.cases(.)) %>%
# Drop empty strings (which are not NAs)
filter(Place != "") %>%
filter(Species == "Nyctalus noctula" &
age == "sad") %>%
select(-Species, -age) %>%
# Make a new variable with places' unique identifiers
unite("place_id", Territory:Place, remove = FALSE) %>%
mutate(across(c(place_id, Territory, Place, sex, Year),
as.factor))
# Loaded packages with their versions
sessionInfo() # to check your locale
df <- df %>%
# count bats per day
count(date) %>%
# choose days where more than 10 bats
filter(n > 10) %>%
# subset with days where more than 10 bats
inner_join(df, by = join_by(date)) %>%
select(-n)
ggplot(data = df, aes(Ra, W
, colour = Year
)
) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", aes(fill = Year)) +
# geom_smooth(aes(fill = Year)) +
labs(x = "Forearm length, mm",
y = "Weight, g")
p1 <- ggplot(data = df, aes(sex, Ra)) +
geom_violin() +
labs(title = "Forearm length",
y = "Forearm length, mm")
p2 <- ggplot(data = df, aes(sex, W)) +
geom_violin() +
labs(title = "Weight",
y = "Weight, g")
gridExtra::grid.arrange(p1, p2, nrow=1, ncol=2)
p1 <- ggplot(data = df, aes(Year, Ra)) +
geom_violin() +
labs(title = "Forearm length",
y = "Ra, mm")
p2 <- ggplot(data = df, aes(Year, W)) +
geom_violin() +
labs(title = "Weight",
y = "W, g")
gridExtra::grid.arrange(p1, p2, nrow=1, ncol=2)
# t ~ Ra
p_Ra_day_4years <- ggplot(data = df, aes(x = day, y = Ra, colour = Year)) +
geom_point() +
geom_smooth(method = "lm", aes(fill = Year)) +
labs(title = "Ra ~ DOY",
x = "Day of the year",
y = "Forearm length, mm")
# t ~ W
p_W_day_4years <- ggplot(data = df, aes(x = day, y = W, colour = Year)) +
geom_point() +
geom_smooth(method = "lm", aes(fill = Year)) +
labs(title = "W ~ DOY",
x = "Day of the year",
y = "Weight, g")
gridExtra::grid.arrange(p_Ra_day_4years, p_W_day_4years, nrow=1, ncol=2)
rm(p_Ra_day_4years, p_W_day_4years)
check_my_var(df, "Ra", "day")
check_my_var(df, "W", "day")
ggplot(df, aes(day)) +
geom_histogram() +
labs(x = "Day of the year",
y = "Number of bats") +
facet_wrap(vars(Year))
# Fit simple linear model
mod <- lm(log(W) ~ log(day), data = df)
# Get residuals
df$BMI <- residuals(mod)
# Drop unused variables
rm(mod)
check_my_var(df, "BMI", "day")
ggplot(data = df, aes(Year, BMI)) +
geom_violin() +
labs(y = "Body Mass Index")
ggplot(data = df, aes(day, BMI, colour = Year)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", aes(fill = Year)) +
labs(x = "Day of the year",
y = "Body Mass Index")
# facet_wrap(vars(sex))
rm(p1, p2)
load(file = "./data/daily_weather_2008-2019.Rdata")
View(df)
View(daily)
daily <- daily %>%
mutate(date = as.Date(date))
df %>%
mutate(id = rownames_to_column())
df %>%
rownames_to_column(var = "id")
df <- df %>%
rownames_to_column(var = "bat_id")
test_df <- df[1:5,]
test.df <- df[1,]
test.df %>% left_join(daily, by = c("place_id", "date"))
test.df <- test.df %>% left_join(daily, by = c("place_id", "date"))
View(test.df)
test.df <- df[1,]
test.df <- test.df %>% right_join(daily, by = c("place_id", "date"))
View(test.df)
test.df <- df[1,]
test.df <- test.df %>% inner_join(daily, by = c("place_id", "date"))
View(test.df)
test.df <- df[1,]
View(test.df)
test.df <- df[1,]
test.df <- test.df %>% left_join(daily, by = c("date"))
View(test.df)
test.df <- df[1,]
tdf <- df %>%
count(place_id, date)
View(tdf)
tdf %>% ggplot(aes(x = date)) +
geom_histogram()
tdf %>% count(date)
tdf %>% count(place_id, date)
tdaily <- daily[daily$place_id == tdf[1,1] &
daily$date == tdf[1,2],
]
View(tdaily)
start.date <- tdaily[, "date", "Prcp", "Tmean"]
start.date <- tdaily[, c("date", "Prcp", "Tmean")]
View(start.date)
one.place.daily <- daily[daily$place_id == tdf[,1] &
daily$date == tdf[,2],
]
start.date <- tdf[1,2]
daily.one.place <- daily[daily$place_id == tdf[1,1],]
View(one.place.daily)
tdf[1,1]
daily.one.place <- daily[daily$place_id == tdf[1,1],]
View(daily.one.place)
start.date <- tdf[1,2]
daily.one.place.start <- daily.one.place[daily.one.place$date <= start.date]
daily.one.place.start <- daily.one.place[daily.one.place$date <= start.date, c("date", "Prcp", "Tmean")]
View(daily.one.place.start)
?reorder
daily.one.place.start <- daily.one.place.start[order(daily.one.place.start, decreasing = TRUE), ]
daily.one.place.start <- daily.one.place.start[order(daily.one.place.start$date, decreasing = TRUE), ]
View(daily.one.place.start)
daily.one.place <- daily[daily$place_id == tdf[1,1] & daily$date <= tdf[1,2],]
View(daily.one.place.start)
View(daily.one.place)
tdf <- df %>%
count(place_id, date)
daily.one.place <- daily[# Select target place
daily$place_id == tdf[1,1] &
# Define starting date
daily$date <= tdf[1,2],
# Select necessary columns
c("date", "Prcp", "Tmean")
]
# Reorder by decreasing date
daily.one.place.start <- daily.one.place[order(daily.one.place$date, decreasing = TRUE), ]
# Reorder by decreasing date
daily.one.place <- daily.one.place[order(daily.one.place$date, decreasing = TRUE), ]
time_lag <- 10
daily.one.event <- daily[# Select target place
daily$place_id == tdf[1,1] &
# Define starting date
daily$date <= tdf[1,2],
# Select necessary columns
c("date", "Prcp", "Tmean")
]
# Reorder by decreasing date
daily.one.event <- daily.one.place[order(daily.one.place$date, decreasing = TRUE), ]
View(daily.one.event)
mean(daily.one.event$date)
mean(daily.one.event$Prcp)
sum(daily.one.event$Prcp)
load(file = "./data/daily_weather_2008-2019.Rdata")
daily <- daily %>%
mutate(date = as.Date(date))
df <- df %>%
rownames_to_column(var = "bat_id")
# Timespan in days
time_lag <- 10
tdf <- df %>%
count(place_id, date)
daily.one.event <- daily[# Select target place
daily$place_id == tdf[1,1] &
# Define starting date
daily$date <= tdf[1,2],
# Select necessary columns
c("date", "Prcp", "Tmean")
]
View(daily.one.event)
# Reorder by decreasing date
daily.one.event <- daily.one.place[order(daily.one.place$date, decreasing = TRUE), ]
View(daily.one.event)
# What is the most early date in the dataset?
min(df$date)
# What is the most early date in the dataset?
min(df$day)
lubridate::day(as.Date("2023-07-01"))
lubridate::yday(as.Date("2023-07-01"))
lubridate::yday(as.Date("2022-07-01"))
lubridate::yday(as.Date("2021-07-01"))
lubridate::yday(as.Date("2022-07-01"))
lubridate::yday(as.Date("2021-07-01"))
lubridate::yday(as.Date("2020-07-01"))
# What is the most early date in the dataset?
min(df$day)
# Cut date range from July 1st to the February 1st of respective year
daily.one.event <- daily.one.event %>%
filter(year(date) = max(year(date))) %>%
# Cut date range from July 1st to the February 1st of respective year
daily.one.event <- daily.one.event %>%
filter(year(date) == max(year(date))) %>%
mutate(month(date) %in% c("July", "June", "May", "April", "March", "February"))
View(daily.one.event)
daily.one.event <- daily[# Select target place
daily$place_id == tdf[1,1] &
# Define starting date
daily$date <= tdf[1,2],
# Select necessary columns
c("date", "Prcp", "Tmean")
]
# Reorder by decreasing date
daily.one.event <- daily.one.place[order(daily.one.place$date, decreasing = TRUE), ]
# Cut date range from July 1st to the February 1st of respective year
daily.one.event <- daily.one.event %>%
filter(year(date) == max(year(date)))
# Cut date range from July 1st to the February 1st of respective year
daily.one.event <- daily.one.event %>%
filter(year(date) == max(year(date))) %>%
mutate(month(date) %in% c("July", "June", "May", "April", "March", "February"))
daily.one.event <- daily[# Select target place
daily$place_id == tdf[1,1] &
# Define starting date
daily$date <= tdf[1,2],
# Select necessary columns
c("date", "Prcp", "Tmean")
]
# Reorder by decreasing date
daily.one.event <- daily.one.place[order(daily.one.place$date, decreasing = TRUE), ]
# Cut date range from July 1st to the February 1st of respective year
daily.one.event <- daily.one.event %>%
filter(year(date) == max(year(date))) %>%
filter(month(date) %in% c("July", "June", "May", "April", "March", "February"))
daily.one.event <- daily[# Select target place
daily$place_id == tdf[1,1] &
# Define starting date
daily$date <= tdf[1,2],
# Select necessary columns
c("date", "Prcp", "Tmean")
]
# Reorder by decreasing date
daily.one.event <- daily.one.place[order(daily.one.place$date, decreasing = TRUE), ]
# Cut date range from July 1st to the February 1st of respective year
daily.one.event <- daily.one.event %>%
filter(year(date) == max(year(date)))
View(daily.one.event)
daily.one.event <- daily[# Select target place
daily$place_id == tdf[1,1] &
# Define starting date
daily$date <= tdf[1,2],
# Select necessary columns
c("date", "Prcp", "Tmean")
]
daily.one.event <- daily[# Select target place
daily$place_id == tdf[1,1] &
# Define starting date
daily$date <= tdf[1,2],
# Select necessary columns
c("date", "Prcp", "Tmean")
]
# Cut date range from July 1st to the February 1st of respective year
daily.one.event <- daily.one.event %>%
arrange(desc(date)) %>%
filter(year(date) == max(year(date)))
View(daily.one.event)
View(daily.one.event)
install.packages("zoo")
library(zoo)
# Create a zoo object with Date as the index
zoo_data <- zoo(daily.one.event$Tmean, order.by = daily.one.event$date)
# Calculate rolling mean with a window of 10 days
rolling_mean <- rollapply(zoo_data, width = 10, FUN = mean, align = "right", fill = NA)
# Convert the result back to a data frame
rolling_mean_df <- data.frame(date = index(rolling_mean), Rolling_Mean_Temperature = coredata(rolling_mean))
View(rolling_mean_df)
# Create a zoo object with Date as the index
zoo_data <- zoo(daily.one.event$Tmean, order.by = daily.one.event$date)
# Calculate rolling mean with a window of 10 days
rolling_mean <- rollapply(zoo_data, width = time_lag, FUN = mean, align = "right", fill = NA)
# Convert the result back to a data frame
rolling_mean_df <- data.frame(date = index(rolling_mean), Rolling_Mean_Temperature = coredata(rolling_mean))
# Sort the resulting data frame by Date in descending order
rolling_mean_df <- rolling_mean_df[order(rolling_mean_df$Date, decreasing = TRUE), ]
# Sort the resulting data frame by Date in descending order
rolling_mean_df <- rolling_mean_df[order(rolling_mean_df$date, decreasing = TRUE), ]
View(rolling_mean_df)
# Convert the result back to a data frame
rolling_mean_df <- data.frame(date = index(rolling_mean), Rolling_Mean_Temperature = coredata(rolling_mean))
# Cut the Date column so that the most recent date is always July 1st, regardless of the year
rolling_mean_df$Date <- cut(rolling_mean_df$date, breaks = "07-01")
# Extract month and day from the Date column
rolling_mean_df$Month <- month(rolling_mean_df$date)
rolling_mean_df$Day <- day(rolling_mean_df$date)
# Assign July 1st as the date, keeping the year constant
rolling_mean_df$date <- ymd(paste(year(rolling_mean_df$date), "07-01", sep = "-"))
# Sort the resulting data frame by Date in descending order
rolling_mean_df <- rolling_mean_df[order(rolling_mean_df$date, decreasing = TRUE), ]
View(rolling_mean_df)
# Calculate rolling mean with a window of 10 days
rolling_mean <- rollapply(zoo_data, width = time_lag, FUN = mean, align = "right", fill = NA)
# Convert the result back to a data frame
rolling_mean_df <- data.frame(date = index(rolling_mean), Rolling_Mean_Temperature = coredata(rolling_mean))
# Sort the resulting data frame by Date in descending order
rolling_mean_df <- rolling_mean_df[order(rolling_mean_df$date, decreasing = TRUE), ]
# Define July 1st regardless of the year
july_1st <- as.Date("07-01", format = "%m-%d")
rolling_mean_df <- rolling_mean_df %>%
filter(date <=  as.Date("07-01", format = "%m-%d"))
daily.one.event$date[1]
year(daily.one.event$date[1])
# Define July 1st regardless of the year
july_1st <- yday(
paste0(
year(daily.one.event$date[1]),
"-07-01")
)
rolling_mean_df <- rolling_mean_df %>%
mutate(doy = yday(date)) %>%
filter(doy <= july_1st) %>%
select(-doy)
View(rolling_mean_df)
# Define day of year for the July 1st for the year of event
Feb_1st <- yday(paste0(year(daily.one.event$date[1]), "-02-01"))
# Define day of year for the July 1st for the year of event
feb_1st <- yday(paste0(year(daily.one.event$date[1]), "-02-01"))
rolling_mean_df <- rolling_mean_df %>%
mutate(doy = yday(date)) %>%
filter(doy <= july_1st & doy >= feb_1st) %>%
select(-doy)
View(rolling_mean_df)
# Define day of year for the July 1st for the year of event
mar_1st <- yday(paste0(year(daily.one.event$date[1]), "-03-01"))
rolling_mean_df <- rolling_mean_df %>%
mutate(doy = yday(date)) %>%
filter(doy <= july_1st & doy >= mar_1st) %>%
select(-doy)
View(rolling_mean_df)
Rolling_Mean_Temperature <- rolling_mean_df[,2]
Rolling_Mean_Temperature
# Rolling Summed Precipitation
# Create a zoo object with Date as the index
zoo_data <- zoo(daily.one.event$Prcp, order.by = daily.one.event$date)
# Calculate rolling mean with a window of 10 days
rolling_mean <- rollapply(zoo_data, width = time_lag, FUN = sum, align = "right", fill = NA)
# Convert the result back to a data frame
rolling_mean_df <- data.frame(date = index(rolling_mean), Rolling_Mean_Precipitation = coredata(rolling_mean))
# Sort the resulting data frame by Date in descending order
rolling_mean_df <- rolling_mean_df[order(rolling_mean_df$date, decreasing = TRUE), ]
# Cut by fixed dates
# July 1st
# Define day of year for the July 1st for the year of event
july_1st <- yday(paste0(year(daily.one.event$date[1]), "-07-01"))
# Define day of year for the July 1st for the year of event
mar_1st <- yday(paste0(year(daily.one.event$date[1]), "-03-01"))
rolling_mean_df <- rolling_mean_df %>%
mutate(doy = yday(date)) %>%
filter(doy <= july_1st & doy >= mar_1st) %>%
select(-doy)
Rolling_Mean_Precipitation <- rolling_mean_df[,2]
Rolling_Mean_Precipitation
# Append vector2 to vector1
combined_matrix <- rbind(Rolling_Mean_Temperature, Rolling_Mean_Precipitation)
View(combined_matrix)
# Transpose the combined matrix
transposed_matrix <- t(combined_matrix)
# View the transposed matrix
transposed_matrix
View(transposed_matrix)
# Append vector2 to vector1
combined_matrix <- c(Rolling_Mean_Temperature, Rolling_Mean_Precipitation)
# Transpose the combined matrix
transposed_matrix <- t(combined_matrix)
# View the transposed matrix
transposed_matrix
