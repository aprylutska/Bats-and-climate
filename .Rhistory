df$Ra_sqDOY <- df$Ra / sqrt(df$day)
# W / square root of day-of-year
df$W_sqDOY <- df$W / sqrt(df$day)
# Ra / log of day-of-year
df$Ra_logDOY <- df$Ra / log(df$day)
# W / log of day-of-year
df$logDOY_Ra <- df$W / log(df$day)
# log of day-of-year / Ra
df$logDOY_Ra <- log(df$day) / df$Ra
# log of day-of-year / W
df$logDOY_W <- log(df$day) / df$W
# log10 Ra
df$log10Ra <- log10(df$Ra)
# log10 W
df$log10W <- log10(df$W)
# Since day of year is not changing hugely during sampling time span in absolute
# measure, scaling to July, 1st = "zero day" may be a possible alternative
# Ra / square root of day-since-Jul1
# Which day-of-year is July, 1st
Jul_1st <- tibble(
year = c(2008, 2011, 2014, 2019),
Jul1_DOY = c(lubridate::yday(as.Date("2008-07-01")),
lubridate::yday(as.Date("2011-07-01")),
lubridate::yday(as.Date("2014-07-01")),
lubridate::yday(as.Date("2019-07-01"))
)
)
Jul_1st
# Only 2008 as a leap year, so we can calculate ratio with zero-day using
# the following loop:
# Straight number of days since July 1st
# Ra
for(i in 1: nrow(df)){
if(df$Year[i] == "2008"){
df$Ra_DsJ1[i] <- df$Ra[i] / (df$day[i] - 181)
} else {
df$Ra_DsJ1[i] <- df$Ra[i] / (df$day[i] - 180)
}
}
# W
for(i in 1: nrow(df)){
if(df$Year[i] == "2008"){
df$W_DsJ1[i] <- df$W[i] / (df$day[i] - 181)
} else {
df$W_DsJ1[i] <- df$W[i] / (df$day[i] - 180)
}
}
# Square rooted number of days since July 1st
# Ra
for(i in 1: nrow(df)){
if(df$Year[i] == "2008"){
df$Ra_sqDsJ1[i] <- sqrt(df$Ra[i] / (df$day[i] - 181))
} else {
df$Ra_sqDsJ1[i] <- sqrt(df$Ra[i] / (df$day[i] - 180))
}
}
# W
for(i in 1: nrow(df)){
if(df$Year[i] == "2008"){
df$W_sqDsJ1[i] <- sqrt(df$W[i] / (df$day[i] - 181))
} else {
df$W_sqDsJ1[i] <- sqrt(df$W[i] / (df$day[i] - 180))
}
}
# Logarithm of number of days since July 1st
# Ra
for(i in 1: nrow(df)){
if(df$Year[i] == "2008"){
df$Ra_logDsJ1[i] <- log(df$Ra[i] / (df$day[i] - 181))
} else {
df$Ra_logDsJ1[i] <- log(df$Ra[i] / (df$day[i] - 180))
}
}
# W
for(i in 1: nrow(df)){
if(df$Year[i] == "2008"){
df$W_logDsJ1[i] <- log(df$W[i] / (df$day[i] - 181))
} else {
df$W_logDsJ1[i] <- log(df$W[i] / (df$day[i] - 180))
}
}
check_my_var <- function(data, dependent_var, independent_var) {
formula <- formula(paste0(dependent_var, " ~ ", independent_var))
years <- list("2008", "2011", "2014", "2019")
yearly_stat <- list()
for (i in 1:length(years)) {
# Fit simple linear model
mod <- lm(formula = formula, data = data[data$Year == years[i],])
# Get response coefficient
coef <- mod$coefficients[2]
# Get p-value from model summary
p_val <- summary(mod)$coefficients[,"Pr(>|t|)"][2]
yearly_stat[[i]] <- c(coef, p_val)
}
yearly_stat <- as.data.frame(t(as.data.frame(yearly_stat)))
rownames(yearly_stat) <- years
colnames(yearly_stat) <- c("Coefficient", "p_value")
# yearly_stat$sign_level <- ifelse(yearly_stat$p-value > 0.05,
#                                  " ",
#                                  ifelse(yearly_stat$p-value <= 0.05 & yearly_stat$p-value > 0.01,
#                                         "*",
#                                         "***")
#                                  )
for (k in 1:nrow(yearly_stat)) {
yearly_stat$sign_level[k] <- if(yearly_stat$p_value[k] > 0.05) {" "} else {"*"}
}
p <- ggplot(data = data, aes_string(x = independent_var, y = dependent_var)) +
geom_point() +
geom_smooth(method = "lm") +
facet_wrap(vars(Year)) +
mytheme
return(list(yearly_stat, p))
}
check_my_var(df, "logDOY_W", "day")
check_my_var(df, "logDOY_Ra", "day")
rm(list = ls()) # reset R's brain
library(lubridate)
library(ggplot2)
library(tidyverse) # for data manipulations
library(easyclimate) # for daily climate data extraction
library(sf) # for spatial operations
# library(patchwork)
# library(jtools)
# Set custom theme for ggplot2 plots
mytheme <- theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
# Loaded packages with their versions
sessionInfo() # to check your locale
# if LC_TIME=uk_UA.UTF-8, your months will be in Ukrainian.
# To fix that, you need to re-map locate into US (will be back after restart R session)
# Set locale to get English months names
# Sys.setlocale("LC_TIME", "en_US.UTF-8") # for Linux
# Sys.setlocale("LC_TIME", "English") # for Windows
df <- read.csv("Homolsha_all_years.csv") # read data from *.csv file
# Set variables classes
df$date <- as.Date(df$Data, "%d.%m.%Y") # convert date to R Data format
df$Place <- as.factor(df$Place)
df$Species <- as.factor(df$Species)
df$sex <- as.factor(df$sex)
df$age <- as.factor(df$age)
df$Year <- year(df$date) #виокремлення року
df$Year <-as.factor (df$Year)
#створення нової колонки з даними про день від початку року
df$day <- yday(df$date)
df$Ra <- sub(",", ".", df$Ra) #заміна ком на крапки в промірах передпліччя
df$W <- sub(",", ".", df$W)
df$Ra <-as.numeric (df$Ra) #присвоєння промірам нумеричного типу даних
df$W <-as.numeric (df$W)
# Delete unused variables
df$Data <- NULL
df$reproductive.status <- NULL
# Take a look at the data
summary(df)
table (df$Species,df$age)
# Subset only some species (e.g., N.noc. , M.daubentonii)
df <- subset(df,
Species %in% c('Nyctalus noctula'
#,'Myotis daubentonii'
) &
age == "sad"
)
summary (df)
ggplot(data = df, aes(Ra, W
, colour = Year
)
) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", aes(fill = Year)) +
# facet_wrap(vars(sex)) +
mytheme
ggplot(data = df, aes(sex, Ra)) +
geom_violin() +
labs(title = "Ra") +
mytheme
ggplot(data = df, aes(sex, W)) +
geom_violin() +
labs(title = "W") +
mytheme
ggplot(data = df, aes(Year, Ra)) +
geom_violin() +
labs(title = "Ra") +
mytheme
ggplot(data = df, aes(Year, W)) +
geom_violin() +
labs(title = "W") +
mytheme
years <- list("2008", "2011", "2014", "2019")
mod <- lm(formula = W ~ day, data = data[data$Year == years[1],])
mod <- lm(formula = W ~ day, data = data[df$Year == years[1],])
mod <- lm(W ~ day, data = data[df$Year == years[1],])
mod <- lm(W ~ day, data = df[df$Year == years[1],])
View(mod)
nrow(df[df$Year == "2014",])
length(mod$residuals)
nrow(df[df$Year == "2008",])
length(mod$residuals)
df1 <- df[!is.na(df$W)]
df1 <- df[!is.na(df$W),]
mod <- lm(W ~ day, data = df1[df$Year == years[1],])
nrow(df1[df1$Year == "2008",])
length(mod$residuals)
View(df1)
mod <- lm(W ~ day, data = df1[df1$Year == years[1],])
nrow(df1[df1$Year == "2008",])
length(mod$residuals)
mod <- lm(W ~ day, data = df1[df1$Year == years[1],])
mod <- lm(W ~ day, data = df1[df1$Year == years[1],])
years <- list("2008", "2011", "2014", "2019")
df <- df[!is.na(df$W),]
for (i in 1:length(years)) {
# Fit simple linear model
mod <- lm(W ~ day, data = df[df$Year == years[i],])
# Get residuals
BCI[[i]] <- mod$residuals
}
BCI <- list()
for (i in 1:length(years)) {
# Fit simple linear model
mod <- lm(W ~ day, data = df[df$Year == years[i],])
# Get residuals
BCI[[i]] <- mod$residuals
}
BCI
BCI[[1]]
df2008 <- tibble(Year == "2008",
BCI = BCI[[1]])
df2008 <- tibble(Year = "2008",
BCI = BCI[[1]])
View(df2008)
df2008 <- df[,df$Year == "2008"]
df2008 <- df[,df$Year == "2008",]
df2008 <- df[,df$Year == "2008",]
df2008 <- df[df$Year == "2008", ]
df2008 <- df[df$Year == "2008", ]
df2011 <- df[df$Year == "2011", ]
df2014 <- df[df$Year == "2014", ]
df2019 <- df[df$Year == "2019", ]
df2008$BCI <- BCI[[1]]
View(df2008)
df2011$BCI <- BCI[[2]]
df2014$BCI <- BCI[[3]]
df2019$BCI <- BCI[[4]]
df <- cbind(df2008, df2011, df2014, df2019)
df <- rbind(df2008, df2011, df2014, df2019)
View(df)
mod$residuals
residuals(mod)
View(df)
# t ~ Ra
p_Ra_day_4years <- ggplot(data = df, aes(x = day, y = Ra, colour = Year)) +
geom_point() +
geom_smooth(method = "lm", aes(fill = Year)) +
ggtitle("Ra ~ DOY") +
mytheme
# t ~ W
p_W_day_4years <- ggplot(data = df, aes(x = day, y = W, colour = Year)) +
geom_point() +
geom_smooth(method = "lm", aes(fill = Year)) +
ggtitle("W ~ DOY") +
mytheme
p_Ra_day_4years
p_W_day_4years
rm(p_Ra_day_4years, p_W_day_4years)
check_my_var <- function(data, dependent_var, independent_var) {
formula <- formula(paste0(dependent_var, " ~ ", independent_var))
years <- list("2008", "2011", "2014", "2019")
yearly_stat <- list()
for (i in 1:length(years)) {
# Fit simple linear model
mod <- lm(formula = formula, data = data[data$Year == years[i],])
# Get response coefficient
coef <- mod$coefficients[2]
# Get p-value from model summary
p_val <- summary(mod)$coefficients[,"Pr(>|t|)"][2]
yearly_stat[[i]] <- c(coef, p_val)
}
yearly_stat <- as.data.frame(t(as.data.frame(yearly_stat)))
rownames(yearly_stat) <- years
colnames(yearly_stat) <- c("Coefficient", "p_value")
# yearly_stat$sign_level <- ifelse(yearly_stat$p-value > 0.05,
#                                  " ",
#                                  ifelse(yearly_stat$p-value <= 0.05 & yearly_stat$p-value > 0.01,
#                                         "*",
#                                         "***")
#                                  )
for (k in 1:nrow(yearly_stat)) {
yearly_stat$sign_level[k] <- if(yearly_stat$p_value[k] > 0.05) {" "} else {"*"}
}
p <- ggplot(data = data, aes_string(x = independent_var, y = dependent_var)) +
geom_point() +
geom_smooth(method = "lm") +
facet_wrap(vars(Year)) +
mytheme
return(list(yearly_stat, p))
}
check_my_var(df, "BCI", "day")
# residuals from a linear regression of the logarithmically transformed number of fungal OTUs against the logarithm of the sequencing depth
# residuals from a linear regression of the logarithmically transformed weigth (W) against the logarithm of the day-of-the-year (day), for each bat individual
years <- list("2008", "2011", "2014", "2019")
df <- df[!is.na(df$W),]
BCI <- list()
for (i in 1:length(years)) {
# Fit simple linear model
mod <- lm(log(W) ~ log(day), data = df[df$Year == years[i],])
# Get residuals
BCI[[i]] <- residuals(mod)
}
BCI[[1]]
df2008 <- df[df$Year == "2008", ]
df2008$BCI <- BCI[[1]]
df2011 <- df[df$Year == "2011", ]
df2011$BCI <- BCI[[2]]
df2014 <- df[df$Year == "2014", ]
df2014$BCI <- BCI[[3]]
df2019 <- df[df$Year == "2019", ]
df2019$BCI <- BCI[[4]]
df <- rbind(df2008, df2011, df2014, df2019)
check_my_var(df, "BCI", "day")
ggplot(data = df, aes(Year, BCI)) +
geom_violin() +
labs(title = "BCI") +
mytheme
ggplot(data = df, aes(day, BCI
, colour = Year
)
) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", aes(fill = Year)) +
# facet_wrap(vars(sex)) +
mytheme
# residuals from a linear regression of the logarithmically transformed number of fungal OTUs against the logarithm of the sequencing depth
# residuals from a linear regression of the logarithmically transformed weigth (W) against the logarithm of the day-of-the-year (day), for each bat individual
# years <- list("2008", "2011", "2014", "2019")
df <- df[!is.na(df$W),]
# Fit simple linear model
mod <- lm(log(W) ~ log(day), data = df[df$Year == years[i],])
# Get residuals
df$BCI <- residuals(mod)
# residuals from a linear regression of the logarithmically transformed number of fungal OTUs against the logarithm of the sequencing depth
# residuals from a linear regression of the logarithmically transformed weigth (W) against the logarithm of the day-of-the-year (day), for each bat individual
# years <- list("2008", "2011", "2014", "2019")
df <- df[!is.na(df$W),]
# Fit simple linear model
mod <- lm(log(W) ~ log(day), data = df)
# Get residuals
df$BCI <- residuals(mod)
View(df)
check_my_var(df, "BCI", "day")
ggplot(data = df, aes(Year, BCI)) +
geom_violin() +
labs(title = "BCI") +
mytheme
rm(list = ls()) # reset R's brain
library(lubridate)
library(ggplot2)
library(tidyverse) # for data manipulations
library(easyclimate) # for daily climate data extraction
library(sf) # for spatial operations
# library(patchwork)
# library(jtools)
# Set custom theme for ggplot2 plots
mytheme <- theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
# Loaded packages with their versions
sessionInfo() # to check your locale
# if LC_TIME=uk_UA.UTF-8, your months will be in Ukrainian.
# To fix that, you need to re-map locate into US (will be back after restart R session)
# Set locale to get English months names
# Sys.setlocale("LC_TIME", "en_US.UTF-8") # for Linux
# Sys.setlocale("LC_TIME", "English") # for Windows
df <- read.csv("Homolsha_all_years.csv") # read data from *.csv file
# Set variables classes
df$date <- as.Date(df$Data, "%d.%m.%Y") # convert date to R Data format
df$Place <- as.factor(df$Place)
df$Species <- as.factor(df$Species)
df$sex <- as.factor(df$sex)
df$age <- as.factor(df$age)
df$Year <- year(df$date) #виокремлення року
df$Year <-as.factor (df$Year)
#створення нової колонки з даними про день від початку року
df$day <- yday(df$date)
df$Ra <- sub(",", ".", df$Ra) #заміна ком на крапки в промірах передпліччя
df$W <- sub(",", ".", df$W)
df$Ra <-as.numeric (df$Ra) #присвоєння промірам нумеричного типу даних
df$W <-as.numeric (df$W)
# Delete unused variables
df$Data <- NULL
df$reproductive.status <- NULL
# Take a look at the data
summary(df)
table (df$Species,df$age)
# Subset only some species (e.g., N.noc. , M.daubentonii)
df <- subset(df,
Species %in% c('Nyctalus noctula'
#,'Myotis daubentonii'
) &
age == "sad"
)
summary (df)
ggplot(data = df, aes(Ra, W
, colour = Year
)
) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", aes(fill = Year)) +
# facet_wrap(vars(sex)) +
mytheme
ggplot(data = df, aes(sex, Ra)) +
geom_violin() +
labs(title = "Ra") +
mytheme
ggplot(data = df, aes(sex, W)) +
geom_violin() +
labs(title = "W") +
mytheme
ggplot(data = df, aes(Year, Ra)) +
geom_violin() +
labs(title = "Ra") +
mytheme
ggplot(data = df, aes(Year, W)) +
geom_violin() +
labs(title = "W") +
mytheme
# t ~ Ra
p_Ra_day_4years <- ggplot(data = df, aes(x = day, y = Ra, colour = Year)) +
geom_point() +
geom_smooth(method = "lm", aes(fill = Year)) +
ggtitle("Ra ~ DOY") +
mytheme
# t ~ W
p_W_day_4years <- ggplot(data = df, aes(x = day, y = W, colour = Year)) +
geom_point() +
geom_smooth(method = "lm", aes(fill = Year)) +
ggtitle("W ~ DOY") +
mytheme
p_Ra_day_4years
p_W_day_4years
rm(p_Ra_day_4years, p_W_day_4years)
# Drop rows with NAs in W
df <- df[!is.na(df$W),]
# Fit simple linear model
mod <- lm(log(W) ~ log(day), data = df)
# Get residuals
df$BCI <- residuals(mod)
# Drop unused variables
rm(mod)
check_my_var <- function(data, dependent_var, independent_var) {
formula <- formula(paste0(dependent_var, " ~ ", independent_var))
years <- list("2008", "2011", "2014", "2019")
yearly_stat <- list()
for (i in 1:length(years)) {
# Fit simple linear model
mod <- lm(formula = formula, data = data[data$Year == years[i],])
# Get response coefficient
coef <- mod$coefficients[2]
# Get p-value from model summary
p_val <- summary(mod)$coefficients[,"Pr(>|t|)"][2]
yearly_stat[[i]] <- c(coef, p_val)
}
yearly_stat <- as.data.frame(t(as.data.frame(yearly_stat)))
rownames(yearly_stat) <- years
colnames(yearly_stat) <- c("Coefficient", "p_value")
# yearly_stat$sign_level <- ifelse(yearly_stat$p-value > 0.05,
#                                  " ",
#                                  ifelse(yearly_stat$p-value <= 0.05 & yearly_stat$p-value > 0.01,
#                                         "*",
#                                         "***")
#                                  )
for (k in 1:nrow(yearly_stat)) {
yearly_stat$sign_level[k] <- if(yearly_stat$p_value[k] > 0.05) {" "} else {"*"}
}
p <- ggplot(data = data, aes_string(x = independent_var, y = dependent_var)) +
geom_point() +
geom_smooth(method = "lm") +
facet_wrap(vars(Year)) +
mytheme
return(list(yearly_stat, p))
}
check_my_var(df, "Ra", "day")
check_my_var(df, "W", "day")
check_my_var(df, "BCI", "day")
ggplot(data = df, aes(Year, BCI)) +
geom_violin() +
labs(title = "BCI") +
mytheme
ggplot(data = df, aes(day, BCI
, colour = Year
)
) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", aes(fill = Year)) +
# facet_wrap(vars(sex)) +
mytheme
ggplot(data = df, aes(day, BCI
, colour = Year
)
) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", aes(fill = Year)) +
# facet_wrap(vars(sex)) +
mytheme
check_my_var(df, "W_Ra", "day")
ggplot(data = df, aes(day, BCI
, colour = Year
)
) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", aes(fill = Year)) +
# facet_wrap(vars(sex)) +
mytheme
